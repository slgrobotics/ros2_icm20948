import math

import rclpy
import sensor_msgs.msg
from rclpy.node import Node
import numpy as np

from .i2c import qwiic_icm20948
from .helpers import G0, std_dev_from_sums, accel_raw_to_mps2, gyro_raw_to_rads

from .filters.madgwick import MadgwickAHRS      # mostly generated by ChatGPT.com

"""
@brief ICM20948 IMU ROS2 node

This node reads data from the ICM20948 IMU over I2C, performs optional filtering and publishes orientation data.

For credits and copyrights see https://github.com/slgrobotics/ros2_icm20948

@author [Sergei Grichine - maintainer]
@date 2026-01-20
"""

class ICM20948Node(Node):
    def __init__(self):
        super().__init__("icm20948_node")

        # Logger
        self.logger = self.get_logger()

        self.logger.info("IP: ICM20948 IMU Sensor node has been started")

        self.declare_parameters(
            namespace='',
            parameters=[
                ('print', False),
                ('i2c_address', [0x68, 0x69]),  # try both common addresses by default
                ('frame_id', 'imu_link'),
                ('raw_only', False),    # When True - only publish raw IMU data - /imu/data_raw and /imu/mag (for imu_tools, without orientation)
                ('pub_rate_hz', 50),
                ('temp_pub_rate_hz', 1.0),
                ('startup_calib_seconds', 3.0),
                ('gyro_calib_max_std_dps', 2.0),       # warn if more. Usually measures around 1.7 deg/s
                ('accel_calib_max_std_mps2', 0.35),    # warn if more, Usually measures around 0.06 m/s^2
                ('magnetometer_bias', [0.0, 0.0, 0.0]),
                ("madgwick_beta", 0.05),   # 0.04-0.2 typical, 0.01 for faster settling after rotation
                ("madgwick_use_mag", True)
            ]
        )

        self._mag_mul_uT_per_lsb = 0.1499  # microT/LSB (verify vs your mag mode, if you change that)

        # Parameters
        self.print = self.get_parameter('print').get_parameter_value().bool_value
        self.logger.info(f"   print: {self.print}")

        # Get i2c_address parameter (list of addresses to try)
        i2c_addresses = self.get_parameter("i2c_address").get_parameter_value().integer_array_value
        self.logger.info(f"   i2c_addresses to try: {[f'0x{addr:X}' for addr in i2c_addresses]}")

        # Try each address until one connects
        self.imu = None
        self.i2c_addr = None
        for addr in i2c_addresses:
            try:
                test_imu = qwiic_icm20948.QwiicIcm20948(address=addr)
                if test_imu.connected:
                    self.imu = test_imu
                    self.i2c_addr = addr
                    self.logger.info(f"   i2c_addr: 0x{self.i2c_addr:X} ✓ (connected)")
                    break
            except Exception as e:
                self.logger.debug(f"   i2c address 0x{addr:X} failed: {e}")
                continue

        if self.imu is None or not self.imu.connected:
            self.logger.error("ICM20948 not connected. Check wiring / I2C bus / addresses.")
            raise RuntimeError("ICM20948 not connected")

        # Note: for Linux on Raspberry Pi iBus=1 is hardcoded in linux_i2c.py 

        self.frame_id = self.get_parameter("frame_id").get_parameter_value().string_value
        self.logger.info(f"   frame_id: {self.frame_id}")

        self.raw_only = self.get_parameter('raw_only').get_parameter_value().bool_value
        self.logger.info(f"   raw_only: {self.raw_only}")

        self.pub_rate_hz = self.get_parameter("pub_rate_hz").get_parameter_value().integer_value
        self.logger.info(f"   pub_rate_hz: {self.pub_rate_hz} Hz")
        
        temp_pub_rate_hz = float(self.get_parameter("temp_pub_rate_hz").value)
        self.logger.info(f"   temp_pub_rate_hz: {temp_pub_rate_hz} Hz")

        # Temperature averaging (accumulate at IMU rate, publish averaged at ~temp_pub_rate_hz)
        self._temp_sum_c = 0.0
        self._temp_count = 0
        # Divider: publish temperature every N IMU ticks
        self._temp_div = max(1, int(round(self.pub_rate_hz / max(0.1, temp_pub_rate_hz))))

        # Gyro and Accel calibration on startup:
        self.startup_calib_seconds = float(self.get_parameter("startup_calib_seconds").value)

        self.gyro_calib_max_std_dps = float(self.get_parameter("gyro_calib_max_std_dps").value)

        self._gyro_bias = [0.0, 0.0, 0.0]      # rad/s
        self._gyro_sum = [0.0, 0.0, 0.0]
        self._gyro_sumsq = [0.0, 0.0, 0.0]

        self.accel_calib_max_std_mps2 = float(self.get_parameter("accel_calib_max_std_mps2").value)

        self._accel_bias = [0.0, 0.0, 0.0]     # m/s^2
        self._accel_sum = [0.0, 0.0, 0.0]
        self._accel_sumsq = [0.0, 0.0, 0.0]

        self.mag_offset_uT = self.get_parameter("magnetometer_bias").get_parameter_value().double_array_value

        self.logger.info(
            f"   mag bias=[{self.mag_offset_uT[0]:.6g}, {self.mag_offset_uT[1]:.6g}, {self.mag_offset_uT[2]:.6g}] microtesla"
        )

        self.logger.info(f"   startup_calib_seconds: {self.startup_calib_seconds}   gyro_calib_max_std_dps: {self.gyro_calib_max_std_dps}  accel_calib_max_std_mps2: {self.accel_calib_max_std_mps2}")

        # Mag calibration accumulators:
        self._mag_avg_calib = [0.0, 0.0, 0.0]  # microtesla
        self._mag_sum = [0.0, 0.0, 0.0]

        self._calib_start_time = self.get_clock().now()
        self._calib_samples = 0
        self._calibration_done = False
        self._shutting_down = False
        # Madgwick-specific variables:
        self._orientation_valid = False
        self._madgwick_updates = 0
        self._last_stamp = None

        # --- Preallocate messages (avoid per-tick allocations) ---
        self._imu_raw_msg = sensor_msgs.msg.Imu()
        self._imu_raw_msg.header.frame_id = self.frame_id
        self._imu_raw_msg.orientation_covariance[0] = -1.0
        self._imu_raw_msg.linear_acceleration_covariance[0] = -1.0
        self._imu_raw_msg.angular_velocity_covariance[0] = -1.0

        self._mag_msg = sensor_msgs.msg.MagneticField()
        self._mag_msg.header.frame_id = self.frame_id
        self._mag_msg.magnetic_field_covariance[0] = -1.0

        self._temp_msg = sensor_msgs.msg.Temperature()
        self._temp_msg.header.frame_id = self.frame_id
        self._temp_msg.variance = 0.25  # (0.5C)^2

        self._imu_msg = None
        if not self.raw_only:
            self._imu_msg = sensor_msgs.msg.Imu()
            self._imu_msg.header.frame_id = self.frame_id

            # Defaults for "unknown"; overwrite when valid
            self._imu_msg.orientation_covariance[0] = -1.0
            self._imu_msg.orientation_covariance[4] = 0.0
            self._imu_msg.orientation_covariance[8] = 0.0

            # Static accel/gyro covariances (tune later)
            self._imu_msg.linear_acceleration_covariance[0] = 0.10
            self._imu_msg.linear_acceleration_covariance[4] = 0.10
            self._imu_msg.linear_acceleration_covariance[8] = 0.10
            self._imu_msg.angular_velocity_covariance[0] = 0.02
            self._imu_msg.angular_velocity_covariance[4] = 0.02
            self._imu_msg.angular_velocity_covariance[8] = 0.02

        self.imu.begin()

        # Choose FSRs, configure the device, and precompute multipliers once.
    
        # the library’s begin() sets accel+gyro to defaults (gpm2, dps250). We may override them here.
        # Practical guidance: https://chatgpt.com/s/t_6956bac992908191894dca63ff53b68d
        # Accel: ±2g (gpm2) Gyro: ±250 dps (dps250) for wheeled home robot, most sensitive to movement.
        self.accel_fsr = qwiic_icm20948.gpm2
        self.gyro_fsr  = qwiic_icm20948.dps250

        self.imu.setFullScaleRangeAccel(self.accel_fsr)
        self.imu.setFullScaleRangeGyro(self.gyro_fsr)

        self._accel_mul = accel_raw_to_mps2(self.accel_fsr)
        self._gyro_mul  = gyro_raw_to_rads(self.gyro_fsr)

        self.logger.info(
            f"   accel_fsr={self.accel_fsr} mul={self._accel_mul:.6g} m/s^2 per LSB, "
            f"gyro_fsr={self.gyro_fsr} mul={self._gyro_mul:.6g} rad/s per LSB"
        )

        # Publishers
        self.imu_raw_pub = self.create_publisher(sensor_msgs.msg.Imu, "/imu/data_raw", 10)
        self.mag_pub = self.create_publisher(sensor_msgs.msg.MagneticField, "/imu/mag", 10)
        self.temp_pub = self.create_publisher(sensor_msgs.msg.Temperature, "/imu/temp", 10)

        self.pub_clk = self.create_timer(1.0 / float(self.pub_rate_hz), self.publish_cback)

        if self.raw_only:
            self.logger.info("   IMU node configured for raw data only; no orientation filter will be used.")
        else:
            self.logger.info("   IMU node configured to provide fused orientation data; Madgwick filter used.")
            # Madgwick params
            self.madgwick_beta = float(self.get_parameter("madgwick_beta").value)
            self.madgwick_use_mag = self.get_parameter("madgwick_use_mag").get_parameter_value().bool_value
            self.filter = MadgwickAHRS(beta=self.madgwick_beta)

            self.logger.info(f"   madgwick_beta: {self.madgwick_beta}")
            self.logger.info(f"   madgwick_use_mag: {self.madgwick_use_mag}")

            # Madgwick-specific publisher (with orientation):
            self.imu_pub = self.create_publisher(sensor_msgs.msg.Imu, "/imu/data", 10)

            # preallocate vectors once to avoid doing it every tick:
            self._gyro_vec = [0.0, 0.0, 0.0]
            self._acc_vec  = [0.0, 0.0, 0.0]
            self._mag_vec  = [0.0, 0.0, 0.0]

        self.logger.info("OK: ICM20948 Node: init successful")

    # Finalize calibration after startup
    def _finish_calibration(self, elapsed_s, n):
        """
        Finalize startup calibration:
        - compute gyro bias + stddev (deg/s)
        - compute accel bias (keep gravity, so at-rest accel ~ +G0 on Z)
        - store mag average at startup (microtesla)
        - optionally initialize Madgwick from accel+mag
        - reset accumulators
        Inputs:
        axm..azm : mean accel during calib (m/s^2)
        mxm..mzm : mean mag during calib (microtesla, with user offset already applied)
        elapsed_s: calibration duration in seconds
        n       : number of samples (float)
        """

        # Means during calibration window
        axm = self._accel_sum[0] / n
        aym = self._accel_sum[1] / n
        azm = self._accel_sum[2] / n
        mxm = self._mag_sum[0] / n
        mym = self._mag_sum[1] / n
        mzm = self._mag_sum[2] / n

        self._calibration_done = True
        self._madgwick_updates = 0
        self._orientation_valid = False

        self.logger.info(f"IMU biases calibrated over {elapsed_s:.2f}s - ({int(n)} samples): ")

        # ---- Gyro bias + noise ----
        bgx = self._gyro_sum[0] / n
        bgy = self._gyro_sum[1] / n
        bgz = self._gyro_sum[2] / n
        self._gyro_bias = [bgx, bgy, bgz]

        g_sx = std_dev_from_sums(self._gyro_sum[0], self._gyro_sumsq[0], n) * 180.0 / math.pi
        g_sy = std_dev_from_sums(self._gyro_sum[1], self._gyro_sumsq[1], n) * 180.0 / math.pi
        g_sz = std_dev_from_sums(self._gyro_sum[2], self._gyro_sumsq[2], n) * 180.0 / math.pi

        self.logger.info(
            f"Gyro  bias=[{bgx:.6g}, {bgy:.6g}, {bgz:.6g}] rad/s,  std dev=[{g_sx:.2f}, {g_sy:.2f}, {g_sz:.2f}] deg/s"
        )
        if max(g_sx, g_sy, g_sz) > self.gyro_calib_max_std_dps:
            self.logger.warning("Gyro calibration std dev is high — robot may have been moving during startup.")

        # ---- Accel bias (expect [0,0,+G0]) ----
        # Keep gravity: subtract offsets so at-rest accel is ~[0,0,+G0]
        bax = axm
        bay = aym
        baz = azm - G0
        self._accel_bias = [bax, bay, baz]

        a_sx = std_dev_from_sums(self._accel_sum[0], self._accel_sumsq[0], n)
        a_sy = std_dev_from_sums(self._accel_sum[1], self._accel_sumsq[1], n)
        a_sz = std_dev_from_sums(self._accel_sum[2], self._accel_sumsq[2], n)

        self.logger.info(
            f"Accel bias=[{bax:.4f}, {bay:.4f}, {baz:.4f}] m/s^2, std=[{a_sx:.3f}, {a_sy:.3f}, {a_sz:.3f}] m/s^2"
        )
        if max(a_sx, a_sy, a_sz) > self.accel_calib_max_std_mps2:
            self.logger.warning("Accel calibration std dev is high — robot may have been moving during startup.")

        # ---- Mag average at startup (microtesla) ----
        self._mag_avg_calib = [mxm, mym, mzm]
        self.logger.info(
            f"Mag    avg=[{mxm:.4f}, {mym:.4f}, {mzm:.4f}] micro Tesla, measurement average during calibration"
            " (after applying magnetometer_bias parameters)"
        )

        # ---- Initialize filter if enabled ----
        if (not self.raw_only) and self.madgwick_use_mag:
            try:
                # flip Y and Z only for the filter input:
                rpy = self.filter.initialize_from_accel_mag(axm, aym, azm, mym, mxm, mzm)
                if rpy[0] is None:
                    self.logger.warning("Madgwick init failed (invalid accel/mag). Keeping identity quaternion.")
                else:
                    #roll, pitch, yaw = rpy  # ENU frame, yaw=0 East
                    roll, pitch, yaw = self.filter.quaternion_rpy_nav()  # Navigation frame, yaw=0 North
                    self.logger.info(
                        "Madgwick init:"
                        f" roll={np.degrees(roll): .2f} deg,"
                        f" pitch={np.degrees(pitch): .2f} deg,"
                        f" yaw={np.degrees(yaw): .2f} deg"
                    )
            except Exception as e:
                self._orientation_valid = False
                if self._imu_msg is not None:
                    self._imu_msg.orientation_covariance[0] = -1.0
                    self._imu_msg.orientation_covariance[4] = 0.0
                    self._imu_msg.orientation_covariance[8] = 0.0
                self.logger.warning(f"Madgwick init threw exception: {e}")

        # ---- Reset accumulators (we don't re-run calib currently) ----
        self._gyro_sum = [0.0, 0.0, 0.0]
        self._gyro_sumsq = [0.0, 0.0, 0.0]
        self._accel_sum = [0.0, 0.0, 0.0]
        self._accel_sumsq = [0.0, 0.0, 0.0]
        self._mag_sum = [0.0, 0.0, 0.0]
        self._calib_samples = 0

    #
    # callback called at pub_rate_hz:
    #
    def publish_cback(self):
        """
        Publishes:
        /imu/data_raw : accel+gyro only, orientation unknown (orientation_cov[0] = -1)
        /imu/data     : accel+gyro + orientation (Madgwick) when raw_only == False
        /imu/mag      : magnetometer (MagneticField)
        /imu/temp     : averaged temperature
        """

        if self._shutting_down:
            return

        # publish only fresh
        if not self.imu.dataReady():
            return

        now = self.get_clock().now()
        try:
            self.imu.getAgmt()
        except Exception as e:
            self.logger.error(f"ICM20948 getAgmt() failed: {e}")
            return

        stamp = now.to_msg()

        # Update headers (stamp changes every tick)
        self._imu_raw_msg.header.stamp = stamp
        self._mag_msg.header.stamp = stamp
        if self._imu_msg is not None:
            self._imu_msg.header.stamp = stamp

        # --- dt for filter ---
        dt = None
        if not self.raw_only:
            if self._last_stamp is None:
                dt = 1.0 / float(self.pub_rate_hz)
            else:
                dt = (now - self._last_stamp).nanoseconds * 1e-9
                if dt <= 0.0:
                    dt = 1.0 / float(self.pub_rate_hz)
                elif dt > 0.2:
                    dt = 0.2
            self._last_stamp = now

        # --- Convert raw -> SI (REP-103: x fwd, y left, z up) ---
        ax_raw =  self.imu.axRaw * self._accel_mul
        ay_raw = -self.imu.ayRaw * self._accel_mul   # <-- flip Y
        az_raw = -self.imu.azRaw * self._accel_mul   # <-- already flipped Z

        gx_raw =  self.imu.gxRaw * self._gyro_mul
        gy_raw = -self.imu.gyRaw * self._gyro_mul    # <-- flip Y
        gz_raw = -self.imu.gzRaw * self._gyro_mul    # <-- already flipped Z

        # Keep mag axes as-is for publishing:
        mx_uT = self.imu.mxRaw * self._mag_mul_uT_per_lsb - float(self.mag_offset_uT[0])
        my_uT = self.imu.myRaw * self._mag_mul_uT_per_lsb - float(self.mag_offset_uT[1])
        mz_uT = self.imu.mzRaw * self._mag_mul_uT_per_lsb - float(self.mag_offset_uT[2])

        # Start with bias-corrected equal to raw
        ax, ay, az = ax_raw, ay_raw, az_raw
        gx, gy, gz = gx_raw, gy_raw, gz_raw

        # --- Calibration accumulation ---
        if not self._calibration_done:
            # Accumulate gyro
            self._gyro_sum[0] += gx
            self._gyro_sum[1] += gy
            self._gyro_sum[2] += gz
            self._gyro_sumsq[0] += gx * gx
            self._gyro_sumsq[1] += gy * gy
            self._gyro_sumsq[2] += gz * gz

            # Accumulate accel
            self._accel_sum[0] += ax
            self._accel_sum[1] += ay
            self._accel_sum[2] += az
            self._accel_sumsq[0] += ax * ax
            self._accel_sumsq[1] += ay * ay
            self._accel_sumsq[2] += az * az

            # Accumulate mag average
            self._mag_sum[0] += mx_uT
            self._mag_sum[1] += my_uT
            self._mag_sum[2] += mz_uT

            self._calib_samples += 1

            elapsed = (now - self._calib_start_time).nanoseconds * 1e-9

            if elapsed >= self.startup_calib_seconds and self._calib_samples > 50:
                n = float(self._calib_samples)

                self._finish_calibration(elapsed, n)

        # --- Apply biases once calibrated (for fused output + filter input) ---
        if self._calibration_done:
            gx -= self._gyro_bias[0]
            gy -= self._gyro_bias[1]
            gz -= self._gyro_bias[2]

            ax -= self._accel_bias[0]
            ay -= self._accel_bias[1]
            az -= self._accel_bias[2]

        # --- Fill and publish RAW IMU (unbiased) ---
        self._imu_raw_msg.linear_acceleration.x = ax_raw
        self._imu_raw_msg.linear_acceleration.y = ay_raw
        self._imu_raw_msg.linear_acceleration.z = az_raw
        self._imu_raw_msg.angular_velocity.x = gx_raw
        self._imu_raw_msg.angular_velocity.y = gy_raw
        self._imu_raw_msg.angular_velocity.z = gz_raw
        self.imu_raw_pub.publish(self._imu_raw_msg)

        # --- Fill and publish MAG (Tesla) ---
        self._mag_msg.magnetic_field.x = mx_uT * 1e-6
        self._mag_msg.magnetic_field.y = my_uT * 1e-6
        self._mag_msg.magnetic_field.z = mz_uT * 1e-6
        self.mag_pub.publish(self._mag_msg)

        # --- Fused IMU (/imu/data) ---
        if self._imu_msg is not None:
            # Fill accel+gyro (bias-corrected):
            self._imu_msg.linear_acceleration.x = ax
            self._imu_msg.linear_acceleration.y = ay
            self._imu_msg.linear_acceleration.z = az
            self._imu_msg.angular_velocity.x = gx
            self._imu_msg.angular_velocity.y = gy
            self._imu_msg.angular_velocity.z = gz

            # Default orientation to "unknown" unless valid
            if not self._orientation_valid:
                self._imu_msg.orientation.x = 0.0
                self._imu_msg.orientation.y = 0.0
                self._imu_msg.orientation.z = 0.0
                self._imu_msg.orientation.w = 1.0
                self._imu_msg.orientation_covariance[0] = -1.0
                self._imu_msg.orientation_covariance[4] = 0.0
                self._imu_msg.orientation_covariance[8] = 0.0

            # Run filter after calibration
            if self._calibration_done:
                try:
                    self.filter.setSamplePeriod(dt)

                    # Use bias-corrected accel+gyro values:
                    self._gyro_vec[0] = gx; self._gyro_vec[1] = gy; self._gyro_vec[2] = gz
                    self._acc_vec[0]  = ax; self._acc_vec[1]  = ay; self._acc_vec[2]  = az

                    if self.madgwick_use_mag:
                        # flip Y and Z for the filter input:
                        self._mag_vec[0] = my_uT
                        self._mag_vec[1] = mx_uT
                        self._mag_vec[2] = mz_uT
                        self.filter.update(self._gyro_vec, self._acc_vec, self._mag_vec)
                    else:
                        self.filter.update(self._gyro_vec, self._acc_vec)

                    self._madgwick_updates += 1
                    if self._madgwick_updates >= 20:
                        self._orientation_valid = True

                    if self._orientation_valid:
                        qx, qy, qz, qw = self.filter.quaternion_xyzw()
                        self._imu_msg.orientation.x = qx
                        self._imu_msg.orientation.y = qy
                        self._imu_msg.orientation.z = qz
                        self._imu_msg.orientation.w = qw
                        self._imu_msg.orientation_covariance[0] = 0.05
                        self._imu_msg.orientation_covariance[4] = 0.05
                        self._imu_msg.orientation_covariance[8] = 0.10

                except Exception as e:
                    self._orientation_valid = False
                    self._imu_msg.orientation_covariance[0] = -1.0
                    self._imu_msg.orientation_covariance[4] = 0.0
                    self._imu_msg.orientation_covariance[8] = 0.0
                    self.logger.warning(f"Madgwick update failed: {e}")

            self.imu_pub.publish(self._imu_msg)

        # --- Temperature averaging/publish ---
        temp_c = self.imu.tmpRaw / 333.87 + 21.0
        self._temp_sum_c += temp_c
        self._temp_count += 1

        publish_temp_now = (self._temp_count % self._temp_div) == 0

        if publish_temp_now:
            avg_temp_c = self._temp_sum_c / float(self._temp_count)
            self._temp_msg.header.stamp = stamp
            self._temp_msg.temperature = round(avg_temp_c, 2)
            self.temp_pub.publish(self._temp_msg)
            self._temp_sum_c = 0.0
            self._temp_count = 0

        # print not too often:
        if self.print and publish_temp_now:
            self.logger.info(
                f"Mag    [{mx_uT:.4f}, {my_uT:.4f}, {mz_uT:.4f}] micro Tesla"
            )
            # print only when fusion is enabled, and orientation is valid:
            if (not self.raw_only) and self._orientation_valid:
                #roll, pitch, yaw = self.filter.quaternion_rpy()      # ENU frame, yaw=0 East
                roll, pitch, yaw = self.filter.quaternion_rpy_nav()  # Navigation frame, yaw=0 North
                self.logger.info(
                    f"Orientation roll={math.degrees(roll):.2f}, pitch={math.degrees(pitch):.2f}, yaw={math.degrees(yaw):.2f} degrees North"
                )

    def destroy_node(self):
        self._shutting_down = True
        try:
            if hasattr(self, "pub_clk") and self.pub_clk is not None:
                self.pub_clk.cancel()
        except Exception:
            pass
        return super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = ICM20948Node()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("Ctrl-C received, shutting down...")
    finally:
        try:
            node.destroy_node()
        except Exception:
            pass
        try:
            rclpy.shutdown()
        except Exception:
            pass

if __name__ == "__main__":
    main()
